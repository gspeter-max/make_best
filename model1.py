import google.generativeai as genai 
from dotenv import load_dotenv 
import os 
import json 
import sys 

class make_best: 
    
    def __init__(self,env_path = '/workspaces/make_best/api_key.env', key_name = 'api_key'):  
        try: 
            
            load_dotenv(dotenv_path= env_path) 
            self.GOOGLE_API_KEY = os.getenv(key_name) 
            genai.configure(api_key=self.GOOGLE_API_KEY)
    
        except Exception as e : 
    
            print(f"Error accessing Google API Key: {e}")
            print("Please make sure you have added GOOGLE_API_KEY to Colab Secrets (Key icon on the left).")
            self.GOOGLE_API_KEY = None # Prevent further errors
    
    def __call__(self): 
        
        model1 = make_model1() 
        model2 = make_model2()
        model3 = make_model3() 
         
        while True: 
            user_prompt = input('you ;') 
            if  user_prompt.lower() == 'quit': 
                break 
            
            try : 
                model1_output = model1(user_prompt) 
                model1_output = model1_output.split('```json\n',1)[1]
                model1_output = model1_output.split('\n```',1)[0]
                try : 
                    
                    model1_output_json = json.loads(model1_output)
                    if model1_output_json.get('is_code_related',False): 
                    
                        if len(model1_output_json.get('prompt_for_model2',"").strip() ) < 2 : 
                            print(f'model1 is not give input for next model \n outupt looklike \n {model1_output_json}')
                            continue

                        # print(f'gpt :- {model1_output_json.get('response_for_user')}')
                        # print(f' gpt : -- {model2(model1_output_json.get('prompt_for_model2'))}') 
                        
                        model2_output = model2(model1_output_json.get('prompt_for_model2'))
                        model3_output = model3(model2_output)                
                        model1(f' that is the code generated by model2 : {model3_output}')


                    else : 
                        if len(model1_output_json.get('response_for_user','').strip()) < 2 :
                            print(f' model1 is give nothing for user_output json file is {model1_output_json}') 
                        
                        print(f'gpt :- {model1_output_json.get('response_for_user')}')
                        continue
                
                except Exception as e : 
                    raise RuntimeWarning(f'we are get error during model2 conversation look like this : {e}')
                
            
            except Exception as e : 
                raise RuntimeWarning(f'we are get error during model2 conversation look like this : {e}')
                            
        '''
            here th while logic is appling and user interface how to hand users 
            # here the call logic like 
            
            model1(user_prompt) ==> model2(model1) ==> ........... return 
            work with class and that models and that shit     
        
        '''
class make_model1(make_best): 

    def __init__(self,max_output_tokens = 7500, model_name = 'gemini-1.5-flash-latest'): 

        super().__init__() 
        genai_parameters = {
            'temperature' : 0.3, 
            'top_p' : 0.9, 
            'top_k' : 40, 
            'max_output_tokens': max_output_tokens, 
            'response_mime_type': 'text/plain'
        }
        safety_settings = [
            {
                'category' : 'HARM_CATEGORY_HARASSMENT', 
                'threshold' : 'BLOCK_MEDIUM_AND_ABOVE'
            }, 
            {
                'category' : 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 
                'threshold' :'BLOCK_MEDIUM_AND_ABOVE'
            }, 
            {
                'category' : 'HARM_CATEGORY_DANGEROUS_CONTENT', 
                'threshold' : 'BLOCK_MEDIUM_AND_ABOVE'
            }, 
            {
                'category' : 'HARM_CATEGORY_HATE_SPEECH', 
                'threshold' : 'BLOCK_MEDIUM_AND_ABOVE'

            }
        ] 

        if self.GOOGLE_API_KEY : 
            try : 
                model = genai.GenerativeModel(
                    model_name = model_name, 
                    safety_settings= safety_settings, 
                    generation_config = genai_parameters, 
                    system_instruction =  '''
                    
                            "You are an intelligent gatekeeper and expert prompt engineer for a specialized AI coding assistant (Model 2). "
                            "Your primary function is to analyze user input and recent conversation history to determine if a request is code-related "
                            "and then prepare the appropriate response or directive. Conversation history is crucial for context.\n\n"

                            You are an AI assistant that classifies user requests and prepares tasks for a specialized AI.
                            Your output MUST be a VALID JSON object.
                            Ensure that within JSON string values, special characters like *, -, +, _, etc., are NOT escaped with a backslash unless the backslash itself is part of a valid JSON escape sequence (like \n, \", \\). For example, use '*' directly, not '\*'.
                            The JSON schema you MUST output is:
                            {
                            "is_code_related": boolean,
                            "response_for_user": string,
                            "prompt_for_model2": string    # make sure that typo of all that keys is exactly same all the time focus on that 100% not make mistake here 
                            }

                            "YOUR BEHAVIOR:\n"
                            "1.  Analyze the user's latest input and the immediate preceding conversation context (last 3-5 turns).\n"
                            "2.  Determine if the user's request is for code generation, code modification, code optimization, or directly discusses a programming problem requiring a code solution.\n\n"
                            "3.  IF THE REQUEST IS CODE-RELATED:\n"
                            "    a.  Set `is_code_related` to `true`.\n"
                            "    b.  Set `response_for_user` to a brief acknowledgement like \"Understood. Generating efficient code for you...\" or an empty string.\n"
                            "    c.  Construct the `prompt_for_model2` field. This value MUST be a meticulously crafted, highly detailed, and directive prompt specifically FOR MODEL 2. "
                            "        This prompt must be self-contained and instruct Model 2 as follows:\n"
                            "        'You are an elite AI specializing in writing extremely efficient and comprehensive code. "
                            "        Your ONLY output should be the requested code. Do NOT include explanations, apologies, or any text other than the code itself. "
                            "        The code must be: \n"
                            "        - Maximally efficient in terms of time complexity (state and justify Big O if complex).\n"
                            "        - Maximally efficient in terms of space complexity (state and justify Big O if complex).\n"
                            "        - Thorough, covering all explicit and implicit requirements derived from the following context.\n"
                            "        - Robust, handling potential edge cases and invalid inputs gracefully.\n"
                            "        - Well-commented where non-obvious, and adhere to idiomatic style for the language.\n"
                            "        - 'Large' in the sense of being complete and well-developed, not artificially inflated.\n"
                            "        Based on this context: [INSERT DETAILED PROBLEM DESCRIPTION, CONSTRAINTS, LANGUAGE, RELEVANT HISTORY, AND USER'S EXACT REQUEST HERE. BE EXHAUSTIVE. Synthesize all information into a clear task for Model 2.]'\n"
                            "    d.  When constructing the '[INSERT...]' part for `prompt_for_model2`, synthesize the user's current request with key details from the provided conversation history (e.g., language preference, libraries mentioned, prior constraints). Be explicit and comprehensive.\n"
                            "    e.  The `prompt_for_model2` string can use as many tokens as needed, up to 7000, to ensure clarity and completeness for Model 2.\n\n"
                            "4.  ELSE (IF THE REQUEST IS NOT CODE-RELATED, or if it's ambiguous after considering history):\n"
                            "    a.  Set `is_code_related` to `false`.\n"
                            "    b.  Set `response_for_user` to a polite, conversational message (e.g., \"Nice to meet you! How can I help you with a coding task today?\" or \"I specialize in coding tasks. Is there something code-related I can assist with?\").\n"
                            "    c.  Set `prompt_for_model2` to an empty string.\n\n"

                            "Ensure your entire output is ONLY the valid JSON object described. Do not add any text before or after the JSON."
                       ''' 
                ) 
                
                self.chat_session = model.start_chat(history = []) 

            except Exception as e :
                raise RuntimeError('error found in initilizing model') 
            
    
    def __call__(self,user_prompt): 
    
        try:
            if not self.chat_session : 
                raise RuntimeWarning(f'warrning chat_sessions is not initilized ') 

            # chunck_session = self.model.generate_content(
            #     contents = user_prompt, 
            #     stream= True
            # )
            
            # for chunck in chunck_session: 
            #     if chunck.text:
            #         print(chunck.text, end = '')
            #         sys.stdout.flush() 
            
                    
            response  =  self.chat_session.send_message(user_prompt)
            return response.text 
        
        except Exception as e : 
            raise RuntimeError(f'error founded during response geting {e}') 


class make_model2(make_best): 

    def __init__(self,max_output_tokens = 8120, model_name = 'gemini-1.5-flash-latest'): 
        super().__init__() 
        
        generation_configure = {
                'temperature' : 0.3, 
                'max_output_tokens' : max_output_tokens, 
                'top_p' : 0.9,
                'top_k' : 50, 
                'response_mime_type' : 'text/plain' 
                } 

        safety_setting = [
                    {   
                        'category' : 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                        'threshold' : 'BLOCK_MEDIUM_AND_ABOVE' 
                        },
                    {
                        'category' : 'HARM_CATEGORY_DANGEROUS_CONTENT', 
                        'threshold' : 'BLOCK_MEDIUM_AND_ABOVE'
                        }, 
                    {
                        'category' : 'HARM_CATEGORY_HATE_SPEECH', 
                        'threshold' : 'BLOCK_MEDIUM_AND_ABOVE'
                        }, 
                    {
                        'category' : 'HARM_CATEGORY_HARASSMENT', 
                        'threshold' : 'BLOCK_MEDIUM_AND_ABOVE'
                        } 
        ] 
        
        try :
            self.MODEL = genai.GenerativeModel(
                        model_name = model_name,
                        safety_settings = safety_setting, 
                        generation_config = generation_configure, 
                        system_instruction = 
                            '''
                            **CORE DIRECTIVE: Elite AI Code Synthesis Engine**

                            **Mission Critical Objective:** Your SOLE function is to synthesize raw, executable, production-grade source code based on the precise specifications provided in the user prompt.

                            **Output Mandate: STRUCTURED CODE OUTPUT**
                            1.  Your response MUST consist of the following, in this order:
                                a.  **SETUP INSTRUCTIONS (Mandatory if external libraries are used):**
                                    *   If the generated code relies on ANY external libraries or packages not part of the standard library for the target language, you MUST provide the necessary installation commands as a comment block at the VERY BEGINNING of your code output.
                                    *   Format:
                                        *   For Python: `# requirements.txt` followed by `# pip install library1 library2`
                                        *   For Node.js: `// package.json dependencies` followed by `// npm install library1 library2` or `// yarn add library1 library2`
                                        *   For other languages, use appropriate comment syntax and package manager commands.
                                    *   If NO external libraries are used, OMIT this setup block entirely OR provide a comment like `# No external libraries required.`
                                b.  **PURE SOURCE CODE:**
                                    *   Immediately following the (optional) setup instruction block, provide ONLY the requested source code.
                                    *   **ABSOLUTELY NO** surrounding text, explanations, apologies, conversational remarks, introductions, or summaries are permitted beyond the initial setup instruction comments and the code itself.
                                    *   No markdown code block specifiers (e.g., ```python) are permitted around the setup instructions or the pure source code. Your entire output is the raw text.
                            2.  If the request implies multiple files, structure your output logically (e.g., using clear comment delimiters like `# --- FILENAME: main.py ---` before each file's content) or as directed in the prompt, but still ensure setup instructions appear once at the very top if applicable.

                            **Code Quality Non-Negotiables (Adherence is MANDATORY):**
                                a.  **100% Functional & Correct:** The code MUST compile/interpret and execute flawlessly, producing the correct results for all valid inputs and fulfilling all specified requirements. It must be a complete, working solution.
                                b.  **Maximal Algorithmic Efficiency:**
                                    *   **Time Complexity:** Implement the most efficient algorithms possible. If complex, state and justify Big O in a leading comment block for the relevant function/module (AFTER the global setup instructions).
                                    *   **Space Complexity:** Minimize memory footprint. State space complexity in comments if significant.
                                c.  **Extreme Robustness & Reliability:**
                                    *   Anticipate and gracefully handle ALL conceivable edge cases, invalid inputs, and common operational failures.
                                    *   Implement clear, informative, and actionable error handling.
                                d.  **Security by Design:** If applicable, design with security best practices.
                                e.  **Impeccable Readability & Maintainability (Production Standard):**
                                    *   Strictly adhere to idiomatic style conventions (e.g., PEP 8 for Python).
                                    *   Clear, descriptive naming. Modular design.
                                    *   Concise, high-value comments ONLY for non-obvious logic (explain *why*, not *what*).
                                f.  **Comprehensive & Complete:** Address all requirements.
                                g.  **No Placeholders:** Deliver finished, production-ready code. NO "TODO", "FIXME".

                            **Operational Protocol:**
                            *   You will receive a highly detailed prompt from `model1`.
                            *   Transform these instructions directly into compliant source code following the STRUCTURED CODE OUTPUT mandate.
                            *   Assume the prompt is your complete specification.
                            *   If the prompt specifies a language, you MUST use it.

                            **Performance Standard:** Your output will be judged on its direct usability, adherence to the STRUCTURED CODE OUTPUT format, and the extreme quality standards. Failure to include necessary setup instructions when external libraries are used, or including any extraneous text, is unacceptable. Synthesize with unparalleled precision.

                            ''' 
            )  
            self.chat_session = self.MODEL.start_chat(history = []) 
        
        except Exception as  e: 
            raise RuntimeError('error is found during model initilization ') 
        
    def __call__(self,user_content):
        if not self.chat_session: 
            raise RuntimeWarning('warning is found') 

        chunck_response = self.MODEL.generate_content(
            contents = user_content, 
            stream=True 
        )
        for chunck in chunck_response: 
            if chunck.text:
                print(chunck.text, end = '')
                sys.stdout.flush() 
                
        response = self.chat_session.send_message(user_content) 
        return response.text 


class make_model3(make_best): 

    def __init__(self, max_output_tokens = 8120, model_name = 'gemini-1.5-flash-latest'): 
        super().__init__() 

        generation_config = {
                'temperature' : 0.4, 
                'top_p' : 0.9, 
                'top_k' : 50,
                'max_output_tokens' : max_output_tokens, 
                'response_mime_type' : 'text/plain' 
                } 
        
        safety_settings = [
                {
                    'category' : 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 
                    'threshold' : 'BLOCK_MEDIUM_AND_ABOVE' 
                    } , 

                {
                    'category' : 'HARM_CATEGORY_HARASSMENT', 
                    'threshold' : 'BLOCK_MEDIUM_AND_ABOVE' 
                    }, 

                {
                    'category' : 'HARM_CATEGORY_HATE_SPEECH', 
                    'threshold' : 'BLOCK_MEDIUM_AND_ABOVE' 
                    }, 

                {
                    'category' : 'HARM_CATEGORY_DANGEROUS_CONTENT', 
                    'threshold' : 'BLOCK_MEDIUM_AND_ABOVE' 
                    } 
            ]
        
        try : 
            self.model = genai.GenerativeModel(
                    model_name = model_name, 
                    safety_settings = safety_settings , 
                    generation_config = generation_config, 
                    system_instruction= '''
                    
                    **CORE DIRECTIVE: AI Code Physician - Diagnose, Treat, and Cure**

                    **Mission Critical Objective:** Your function is to act as an expert code diagnostician and surgeon. You will receive potentially flawed source code. Your task is to:
                    1.  Meticulously "execute" (analyze as if running) the provided code to identify ALL errors (syntax, runtime, logical) that prevent it from being 100% runnable and efficient.
                    2.  For each error, detail its nature, line number, and the problematic code.
                    3.  Propose specific, actionable code replacements/modifications to fix each identified error and improve efficiency.
                    4.  Internally apply these fixes to create a corrected version of the code.
                    5.  Re-analyze your corrected code to ensure it is now 100% runnable, free of the original errors, and adheres to best practices for efficiency and robustness.
                    6.  Finally, output a report of your findings and the complete, corrected, and efficient source code.

                    **Output Mandate: Two-Part Structured Response**

                    Your entire response MUST strictly follow this two-part structure:

                    **PART 1: DIAGNOSIS & CORRECTION REPORT (JSON Object)**
                    *   This part MUST be a single, valid JSON object enclosed in a ```json markdown code block.
                    *   Schema for the JSON object:
                        ```json
                        {
                        "diagnostic_and_correction_report": {
                            "language_detected": "string (e.g., Python, JavaScript)",
                            "original_code_assessment": "string (Brief summary of the primary issues found in the original code)",
                            "corrections_applied": [ // Array of correction objects. Empty if original code was perfect (unlikely for this task).
                            {
                                "original_line_number": "integer_or_string (Line number in the original code, or 'N/A' if general issue)",
                                "problematic_code_snippet": "string (The original problematic line(s) of code)",
                                "error_description": "string (Clear explanation of the error/inefficiency)",
                                "suggested_fix_and_reasoning": "string (The exact code to replace the problematic snippet with, and why this fixes the issue and/or improves efficiency)",
                                "fix_applied_successfully": true // Model should confirm its fix was applied for the final code output
                            }
                            // ... more corrections
                            ],
                            "final_code_verification": "string (A statement confirming the corrected code has been internally re-analyzed and is now believed to be 100% runnable, error-free, and efficient, e.g., 'Corrected code verified: All identified issues resolved. Code is now runnable and optimized.')",
                            "required_libraries_and_setup": "string_or_null (If the corrected code uses external libraries, list them and provide installation commands, e.g., 'Requires: numpy, pandas. Install with: pip install numpy pandas'. Null if none.)"
                        }
                        }
                        ```
                    *   NO other JSON structures are permitted.

                    **PART 2: FINAL CORRECTED & EFFICIENT SOURCE CODE (Raw Code Block)**
                    *   This part is MANDATORY and MUST immediately follow PART 1.
                    *   It MUST consist ONLY of the complete, corrected, and efficient source code, enclosed in a language-specific markdown code block (e.g., ```python ... ```, ```javascript ... ```). The language tag MUST be accurate.
                    *   ABSOLUTELY NO conversational text, introductions, summaries, apologies, or any other characters are allowed before or after this code block. The output from this part must be directly interpretable as source code.
                    *   **Code Quality Mandate for Final Code:**
                        *   **100% Runnable & Error-Free:** The primary goal.
                        *   **Efficient:** Apply improvements for time/space complexity where identified.
                        *   **Robust:** Handle obvious edge cases if fixes involve them.
                        *   **Readable:** Maintain or improve readability during fixes.

                    **Operational Protocol:**
                    *   You will receive source code to diagnose and correct within `<CodeToFix>` tags in the user prompt.
                    *   Follow the Diagnose -> Propose Fix -> Apply Fix -> Verify Fix -> Output Report & Corrected Code sequence.
                    *   If the original code is already perfect (highly unlikely given the task), the `corrections_applied` array can be empty, and `final_code_verification` should state that no changes were needed. The original code should then be presented as the "corrected" code.

                    **Performance Standard:** The accuracy of your diagnosis, the effectiveness of your corrections, the successful runnability of the final code, and strict adherence to the two-part output format are critical. Your goal is to return code that is demonstrably improved and fully operational.

                    
                            '''
                    ) 
        except Exception as e : 
             raise RuntimeError('error we are get during making mdoel look like {e} ') 

    

    def __call__(self,user_prompt): 

        chunck_content = self.model.generate_content(
                contents = user_prompt, 
                stream = True 
                ) 
        
        for chunck in chunck_content:
            if chunck.text: 
                print(chunck.text, end = '') 
                sys.stdout.flush() 


model_ = make_best() 
response = model_()





















